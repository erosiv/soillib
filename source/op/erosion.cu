#ifndef SOILLIB_NODE_EROSION_CU
#define SOILLIB_NODE_EROSION_CU
#define HAS_CUDA

#include <soillib/util/error.hpp>

#include <cuda_runtime.h>
#include <math_constants.h>
#include <iostream>

#include <soillib/op/common.hpp>
#include <soillib/op/gather.hpp>
#include <soillib/op/erosion.hpp>

#include "erosion_thermal.cu"

namespace soil {

//
// Randstate and Estimate Initialization / Filtering
//

__global__ void seed(buffer_t<curandState> buffer, const size_t seed, const size_t offset) {
  const unsigned int n = blockIdx.x * blockDim.x + threadIdx.x;
  if(n >= buffer.elem()) return;
  curand_init(seed, n, offset, &buffer[n]);
}

__global__ void reset(model_t model){
  
  const unsigned int n = blockIdx.x * blockDim.x + threadIdx.x;
  if(n >= model.elem) return;
  
  // Reset Estimation Buffers

  model.discharge_track[n] = 0.0f;
  model.momentum_track[n] = vec2(0.0f);

}

__global__ void filter(model_t model, const param_t param){

  const unsigned int n = blockIdx.x * blockDim.x + threadIdx.x;
  if(n >= model.elem) return;

  // Apply Simple Exponential Filter to Noisy Estimates

  model.discharge[n] = glm::mix(model.discharge[n], model.discharge_track[n], param.lrate);
  model.momentum[n] = glm::mix(model.momentum[n], model.momentum_track[n], param.lrate);

}

//
// Erosion Kernels
//

__global__ void solve(model_t model, const size_t N, const param_t param){

  const unsigned int ind = blockIdx.x * blockDim.x + threadIdx.x;
  if(ind >= N) return;

  //
  // Parameters
  //

  // Scaled Domain Parameters
  const vec3 scale = model.scale * 1E3f;  // Cell Scale [m]
  const vec2 cl = vec2(scale.x, scale.y); // Cell Length [m, m]
  const float Ac = scale.x*scale.y;       // Cell Area [m^2]

  const float R = param.rainfall;         // Rainfall Amount  [m/y]
  const float g = param.gravity;          // Specific Gravity [m/s^2]
  const float nu = param.viscosity;// * 24000.0f;      // Kinematic Viscosity [m^2/s]

  const float dt = param.timeStep;        // Geological Timestep [y]
  const float kd = param.depositionRate;  // Fluvial Deposition Rate [1/y]
  const float ks = param.suspensionRate;  // Fluvial Suspension Rate [(m^3/y)^-0.4]

  //
  // Position Sampling Procedure:
  //  Note: If we isolate this, we also wish to return the probability
  //  that any individual sample was chosen. For now, it is uniform.
  //  Additionally, this can be area based, but ultimately depends
  //  on the actual implementation of the sampling procedure.
  //

  curandState* randState = &model.rand[ind];
  vec2 pos = vec2{
    curand_uniform(randState)*float(model.index[0]),
    curand_uniform(randState)*float(model.index[1])
  };
  const float P = 1.0f / float(model.index.elem());
  int find = model.index.flatten(pos);

  //
  // Mass-Transfer Scaling Parameters
  //

  const float Z = Ac * scale.z; // Height Conversion [m^3]
  const float Q = P * float(N); // Sampling Probability Scale

  //
  // Transport Initial Condition
  //

  float vol = Ac * R; // [m^3/y]
  float sed = 0.0f;

  //
  // Trajectory Initial Condition
  //

  // Surface Normal Vector
  lerp5_t<float> lerp;
  lerp.gather(model.height, model.sediment, model.index, ivec2(pos));
  const vec2 grad = lerp.grad(scale);
  const vec3 normal = glm::normalize(vec3(-grad.x, -grad.y, 1.0f));

  // Average Local Velocity
  const vec2 momentum = model.momentum[find];
  const float discharge = model.discharge[find];
  vec2 average_speed = vec2(0.0f);
  if(discharge > 0.0f) {
    average_speed = momentum / discharge;
  }

  // Initial Velocity Estimate
  vec2 speed = g * vec2(normal.x, normal.y) + nu * average_speed;
  if(glm::length(speed) == 0.0f)
    return;

  float ds = glm::length(cl) / glm::length(speed);
  vec2 npos = pos + ds*(speed / cl);
  vec2 dspeed = speed;

  // Solution Loop:
  //  Solve Conservation Law along Characteristic
  //  Generated by the Flow.

  for(size_t age = 0; age < param.maxage; ++age){

    //
    // Accumulate Estimated Values
    //

    // Note: Accumulation Occurds at Current Position

    atomicAdd(&model.discharge_track[find], (1.0f/P/N)*vol);
    atomicAdd(&model.momentum_track[find].x, (1.0f/P/N)*vol*dspeed.x);
    atomicAdd(&model.momentum_track[find].y, (1.0f/P/N)*vol*dspeed.y);

    //
    // Mass-Transfer
    //  Compute Equilibrium Mass from Slope and Discharge
    //  Transfer Mass and Scale by Sampling Probability
    
    float discharge = model.discharge[find];
    float slope = -param.exitSlope;
    float h0 = (model.height[find] + model.sediment[find])*scale.z;
    float h1 = h0 + slope * glm::length(cl);
    
    if(!model.index.oob(npos)){
      const int nind = model.index.flatten(npos);
      h1 = (model.height[nind] + model.sediment[nind])*scale.z;
      slope = (h1 - h0)/glm::length(cl);
    }

    // Activation Function
    float alpha = (slope < 0.0f)?1.0f:0.0f;
    float suspend = dt * ks * vol * slope * alpha * pow(discharge, 0.4f); // [kg]
    float deposit = dt * kd * sed;                                        // [kg]

    /*
    // Single Material, Implicit Euler Scheme
    //  This use an activation function which lowers the amount transferred
    //  which scales with the amount of equilibriation force. Note that this
    //  tends to over-damp, which is why we don't use it.

    float kq = ks * vol * alpha * pow(discharge, 0.4f) / glm::length(cl);
    float transfer = 1.0f / (1.0f + dt * kq) * (suspend + deposit);
    atomicAdd(&model.height[find], transfer / Z / Q);
    sed -= transfer;
    */

    // Single Material, Explicit Euler Scheme
    //  This use an activation function (maxtransfer), which limits the
    //  total amount of mass that can be moved based on the slope.
    //  Similar to the implicit scheme, which uses a similar construction
    //  but that scales with the rate.
  
    // Note: Maxtransfer here is damped for stability. This should be
    //  attempted to be removed using alternative stabilizing methods.
//    float transfer = (deposit + suspend);
//    const float maxtransfer = 0.1f * slope * glm::length(cl) / scale.z * Z * Q;
//    const float tmin = transfer * glm::min(1.0f, glm::abs(maxtransfer/transfer));
//    const float tmax = sed;
//    transfer = glm::clamp(transfer, tmin, tmax);
//
//    atomicAdd(&model.height[find], transfer / Z / Q);
//    sed -= transfer;

    // Multi-Material Mass Transfer
    float transfer = (deposit + suspend);
    const float maxtransfer = 0.1f * slope * glm::length(cl) / scale.z * Z * Q;
    const float tmin = transfer * glm::min(1.0f, glm::abs(maxtransfer/suspend));
    const float tmax = sed;
    transfer = glm::clamp(transfer, tmin, tmax);

    if(transfer > 0.0f){  // Add Material to Map (Note: Single Material Model)

      atomicAdd(&model.sediment[find], transfer / Z / Q);
      sed -= transfer;

    }

    else if(transfer < 0.0f){ // Remove Sediment from Map

      const float maxtransfer = model.sediment[find] * Z * Q;
      float t1 = transfer * glm::min(1.0f, glm::abs(maxtransfer/transfer));
      atomicAdd(&model.sediment[find], t1 / Z / Q);
      sed -= t1;

      transfer -= t1;
      atomicAdd(&model.height[find], transfer / Z / Q);
      sed -= transfer;

    }

    //
    // Integrate Sub-Solution Quantities
    //  Note: Integrated in Quasi-Static Time
    //    using an Implicit Forward Scheme

    vol = 1.0f/(1.0f + ds*param.evapRate)*vol;
    dspeed = 1.0f/(1.0f + ds*nu)*dspeed;

    //
    // Flow Integration / Trajectory
    //

    pos = npos;
    if(model.index.oob(pos))
      break;

    find = model.index.flatten(pos);

    lerp5_t<float> lerp;
    lerp.gather(model.height, model.sediment, model.index, ivec2(pos));
    const vec2 grad = lerp.grad(scale);
    const vec3 normal = glm::normalize(vec3(-grad.x, -grad.y, 1.0f));

    discharge = model.discharge[find];
    const vec2 momentum = model.momentum[find];
    vec2 average_speed = vec2(0.0f);
    if(discharge > 0.0f){
      average_speed = momentum / discharge;
    }

    // Implicit Euler Forward Integration:

    speed = speed + ds * g * vec2(normal.x, normal.y);
    speed = 1.0f/(1.0f + ds*nu)*speed + ds*nu/(1.0f + ds*nu)*average_speed;

    if(glm::length(speed) == 0.0f)
      break;

    ds = glm::length(cl)/glm::length(speed);
    npos = pos + ds * (speed / cl);

  }

}

//
// Erosion Function
//

void erode(model_t& model, const param_t param, const size_t steps){

  if(model.height.host() != soil::host_t::GPU){
    throw soil::error::mismatch_host(soil::host_t::GPU, model.height.host());
  }

  if(model.discharge.host() != soil::host_t::GPU){
    throw soil::error::mismatch_host(soil::host_t::GPU, model.discharge.host());
  }

  if(model.momentum.host() != soil::host_t::GPU){
    throw soil::error::mismatch_host(soil::host_t::GPU, model.momentum.host());
  }
  
  //
  // Initialize Rand-State Buffer (One Per Sample)
  //

  const size_t n_samples = param.samples;

  // note: the offset in the sequence should be number of times rand is sampled
  // that way the sampling procedure becomes deterministic

  if(model.rand.elem() != n_samples){
    model.rand = soil::buffer_t<curandState>(n_samples, soil::host_t::GPU);
    seed<<<block(n_samples, 512), 512>>>(model.rand, 0, 2 * model.age);
    cudaDeviceSynchronize();
  }

  //
  // Estimate Buffers
  //

  model.discharge_track = soil::buffer_t<float>(model.discharge.elem(), soil::host_t::GPU);
  model.momentum_track = soil::buffer_t<vec2>(model.discharge.elem(), soil::host_t::GPU);

  //
  // Execute Solution
  //

  for(size_t step = 0; step < steps; ++step){

    //
    // Reset, Solve, Filter, Apply
    //

    reset<<<block(model.elem, 1024), 1024>>>(model);
    cudaDeviceSynchronize();

    solve<<<block(n_samples, 512), 512>>>(model, n_samples, param);
    cudaDeviceSynchronize();
 
    filter<<<block(model.elem, 1024), 1024>>>(model, param);
    cudaDeviceSynchronize();

    //
    // Debris Flow Kernel
    //

    debris_flow<<<block(n_samples, 512), 512>>>(model, n_samples, param);
    cudaDeviceSynchronize();

    model.age++; // Increment Model Age for Rand-State Initialization

  }

}

} // end of namespace soil

#endif